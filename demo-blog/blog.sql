/*
SQLyog Ultimate v12.08 (64 bit)
MySQL - 8.0.19 : Database - blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`blog` /*!40100 DEFAULT CHARACTER SET utf8 */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `blog`;

/*Table structure for table `t_blog` */

DROP TABLE IF EXISTS `t_blog`;

CREATE TABLE `t_blog` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  `first_picture` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '原创',
  `views` int DEFAULT NULL,
  `appreciation` int NOT NULL DEFAULT '0',
  `share_statement` int NOT NULL DEFAULT '0',
  `commentabled` int NOT NULL DEFAULT '0',
  `published` int NOT NULL DEFAULT '0',
  `recommend` int NOT NULL DEFAULT '0',
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `type_id` bigint DEFAULT NULL,
  `user_id` bigint DEFAULT NULL,
  `description` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  `tag_ids` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `comment_count` int DEFAULT NULL COMMENT '评论数量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

/*Data for the table `t_blog` */

insert  into `t_blog`(`id`,`title`,`content`,`first_picture`,`flag`,`views`,`appreciation`,`share_statement`,`commentabled`,`published`,`recommend`,`create_time`,`update_time`,`type_id`,`user_id`,`description`,`tag_ids`,`comment_count`) values (1,'Synchronized关键字','# \r\n\r\n# 1、对Synchronized的了解\r\n\r\nsynchronized关键字解决的是多个线程之间访问资源的的同步性。\r\n\r\nsynchronized可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\r\n\r\n## 2、使用synchronized\r\n\r\n- **修饰实例方法**：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。\r\n- **修饰静态方法**：  **访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。 \r\n- **修饰代码块**：指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。\r\n\r\n **总结：** synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 。因为JVM中，字符串常量池具有缓存功能！ \r\n\r\n还记得[单例模式](https://blog.csdn.net/hello_cmy/article/details/105344319)中的双重校验锁吗？里面就用到了synchronized关键字。\r\n\r\n再来回顾一下，争取手写！在看面试题的时候，就有一个面试题让你手写单例模式。\r\n\r\n```java\r\npackage com.cc.single;\r\n\r\n/**\r\n * 双重校验锁实现单例模式\r\n */\r\npublic class Singleton {\r\n\r\n    //volatile可以禁止指令重排\r\n    private volatile static Singleton uniqueInstance;\r\n\r\n    private Singleton() {\r\n\r\n    }\r\n\r\n    public static Singleton getInstance() {\r\n        //先判断对象是否已经实例过，没有实例化过才能进入加锁代码\r\n        if(uniqueInstance == null) {\r\n            //类对象加锁\r\n            synchronized (Singleton.class) {\r\n                if(uniqueInstance == null) {\r\n                    uniqueInstance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return uniqueInstance;\r\n    }\r\n}\r\n```\r\n\r\n另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。\r\n\r\nuniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\r\n\r\n1. 为 uniqueInstance 分配内存空间\r\n2. 初始化 uniqueInstance\r\n3. 将 uniqueInstance 指向分配的内存地址\r\n\r\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时uniqueInstance 还未被初始化。\r\n\r\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','http://qak6euco1.bkt.clouddn.com/tu1.jpg?e=1590117079&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:qxfZcz0HUiP8i0TIEH84TKv7Q2k=&attname=','原创',29,1,1,1,1,1,'2020-03-12 08:25:47','2020-05-22 10:22:33',12,1,'synchronized关键字解决的是多个线程之间访问资源的的同步性。','6',1),(13,'测试博客','内容 。。。。。。。','http://qak6euco1.bkt.clouddn.com/tu2.jpg?e=1590117079&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:6SV9qd_JxN9wdasKkHGI7DoX1LQ=&attname=','原创',14,1,1,1,1,1,'2020-05-19 11:06:16','2020-05-22 10:25:29',12,1,'描述。。。。。。。','6',3),(14,'volatile','\r\n**1、保证可见性**\r\n\r\n**2、不保证原子性**\r\n\r\n**3、禁止指令重排**\r\n\r\n> 1、保证可见性\r\n\r\n```java\r\npackage com.cc.tvolatile;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class JMMDemo {\r\n\r\n    //不加 volatile 程序就会死循环\r\n    //加 volatile 可以保证可见性\r\n    private volatile static int num = 0;\r\n\r\n    public  static void main(String[] args) {\r\n\r\n        new Thread(()->{\r\n            while(num == 0) {\r\n\r\n            }\r\n        }).start();\r\n\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        num = 1;\r\n        System.out.println(num);\r\n    }\r\n}\r\n```\r\n\r\n> 2、不保证原子性\r\n\r\n原子性：不可分割\r\n\r\n线程A在执行任务的时候，不能被打扰的，也不能被分割。要么同时成功，要么同时失败。\r\n\r\n```java\r\npackage com.cc.tvolatile;\r\n\r\n\r\n//volatile不保证原子性\r\npublic class VDemo02 {\r\n\r\n    //volatile不保证原子性\r\n    private  volatile static int num = 0;\r\n\r\n    public static void add() {\r\n        num++;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        //理论上num结果应该为2万\r\n        for (int i = 1; i <= 20 ; i++) {\r\n            new Thread(()->{\r\n                for (int j = 0; j < 1000; j++) {\r\n                    add();\r\n                }\r\n            }).start();\r\n        }\r\n\r\n        while (Thread.activeCount() > 2) {//main.gc\r\n            Thread.yield();\r\n        }\r\n\r\n        System.out.println(Thread.currentThread().getName()+ \" \" + num);\r\n    }\r\n}\r\n```\r\n\r\nnum的结果理论上应该是2万，但是你运行发现每次结果都不固定，大部分时候都不是两万。\r\n\r\n如下，我截取了一个结果。\r\n\r\n```java\r\n//输出结果\r\nmain 18779\r\n```\r\n\r\n可以加 lock 和 synchronized，来保证原子性。\r\n\r\n如下：\r\n\r\n```java\r\npackage com.cc.tvolatile;\r\n\r\n//volatile不保证原子性\r\npublic class VDemo02 {\r\n\r\n    //volatile不保证原子性\r\n    private static int num = 0;\r\n\r\n    public static synchronized void add() {\r\n        num++;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        //理论上num结果应该为2万\r\n        for (int i = 1; i <= 20 ; i++) {\r\n            new Thread(()->{\r\n                for (int j = 0; j < 1000; j++) {\r\n                    add();\r\n                }\r\n            }).start();\r\n        }\r\n\r\n        while (Thread.activeCount() > 2) {//main.gc\r\n            Thread.yield();\r\n        }\r\n\r\n        System.out.println(Thread.currentThread().getName()+ \" \" + num);\r\n    }\r\n}\r\n```\r\n\r\n如果不加 lock 和 synchronized，怎么样来保证原子性呢？\r\n\r\n![1586233382513](../assets/1586233382513.png)\r\n\r\n\r\n\r\n使用原子类，解决原子性问题。\r\n\r\n![1586233713529](../assets/1586233713529.png)\r\n\r\n```java\r\npackage com.cc.tvolatile;\r\n\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\n//volatile不保证原子性\r\npublic class VDemo02 {\r\n\r\n    //volatile不保证原子性\r\n    //原子类的 Integer\r\n    private volatile static AtomicInteger num = new AtomicInteger();\r\n\r\n    public static void add() {\r\n        //num++; //不是原子性的操作\r\n        num.getAndIncrement();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n\r\n        //理论上num结果应该为2万\r\n        for (int i = 1; i <= 20 ; i++) {\r\n            new Thread(()->{\r\n                for (int j = 0; j < 1000; j++) {\r\n                    add();\r\n                }\r\n            }).start();\r\n        }\r\n\r\n        while (Thread.activeCount() > 2) {//main.gc\r\n            Thread.yield();\r\n        }\r\n\r\n        System.out.println(Thread.currentThread().getName()+ \" \" + num);\r\n    }\r\n}\r\n```\r\n\r\n> 3、指令重排\r\n\r\n什么是 指令重排：**你写的程序，计算机并不是按照你写的那样去执行的。** \r\n\r\n源代码-->编译器优化的重排--> 指令并行也可能会重排--> 内存系统也会重排---> 执行 \r\n\r\n**处理器在进行指令重排的时候，考虑：数据之间的依赖性！** \r\n\r\n```java\r\nint x = 1; // 1\r\nint y = 2; // 2\r\nx = x + 5; // 3\r\ny = x * x; // 4\r\n我们所期望的：1234 但是可能执行的时候回变成 2134 1324\r\n可不可能是 4123！\r\n```\r\n\r\n可能造成影响的结果： a b x y 这四个值默认都是 0； \r\n\r\n| 线程A | 线程B |\r\n| ----- | ----- |\r\n| x=a   | y=b   |\r\n| b=1   | a=2   |\r\n\r\n正常的结果： x = 0；y = 0；但是可能由于指令重排 \r\n\r\n| 线程A | 线程B |\r\n| ----- | ----- |\r\n| b=1   | a=2   |\r\n| x=a   | y=b   |\r\n\r\n指令重排导致的诡异结果： x = 2；y = 1； \r\n\r\n\r\n\r\n**volatile可以避免指令重排：**\r\n\r\n内存屏障。CPU指令。作用： \r\n\r\n1、保证特定的操作的执行顺序！ \r\n\r\n2、可以保证某些变量的内存可见性 （利用这些特性volatile实现了可见性）\r\n\r\n![1586234990582](../assets/1586234990582.png)\r\n\r\n**Volatile** **是可以保持 可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生！** ','http://qak6euco1.bkt.clouddn.com/tu1.jpg?e=1590117079&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:qxfZcz0HUiP8i0TIEH84TKv7Q2k=&attname=','原创',25,1,1,1,1,1,'2020-05-22 10:24:31','2020-05-22 10:24:31',12,1,'1、保证可见性\r\n\r\n2、不保证原子性\r\n\r\n3、禁止指令重排','6',NULL),(15,'ArrayList','# ArrayList\r\n\r\n### 1、简单说一下ArrayList用来干嘛的？\r\n\r\nArrayList是数组列表，主要用来装载数据， 当我们装载的是基本类型的数据int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组 `Object[] elementData`。 \r\n\r\nArrayList 查询效率高，增删效率低，线程不安全。使用频率很高。\r\n\r\n### 2、LinkedList、 Vector 与ArrayList\r\n\r\n我们使用多的是查询，ArrayList查询效率高。\r\n\r\n如果涉及频繁的增删可以使用LinkedList。\r\n\r\n如果需要线程安全就使用Vector。\r\n\r\n### 3、ArrayList扩容机制\r\n\r\n 数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？ \r\n\r\n 其实实现方式比较简单，他就是通过数组扩容的方式去实现的。 \r\n\r\n看源码！\r\n\r\n> 初始容量为10\r\n\r\n```\r\n//默认初始容量为10\r\nprivate static final int DEFAULT_CAPACITY = 10;\r\n```\r\n\r\n> ArrayList是怎么进行扩容的\r\n\r\n还是找源码。\r\n\r\n```java\r\nprivate void grow(int minCapacity) {\r\n        // overflow-conscious code\r\n        int oldCapacity = elementData.length;\r\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n        if (newCapacity - minCapacity < 0)\r\n            newCapacity = minCapacity;\r\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n            newCapacity = hugeCapacity(minCapacity);\r\n        // minCapacity is usually close to size, so this is a win:\r\n        elementData = Arrays.copyOf(elementData, newCapacity);\r\n    }\r\n```\r\n\r\n可以看到扩容后的`新容量=之前的容量+之前的容量右移1位（也就是除于2）`\r\n\r\n举个例子来看一下：\r\n\r\n现在我们使用默认的初始容量为10，填满元素。\r\n\r\n![1586831510412](../assets/1586831510412.png)\r\n\r\n首先他会重新定义一个长度为10+10/2的数组也就是新增一个长度为15的数组。\r\n\r\n![1586831599275](../assets/1586831599275.png)\r\n\r\n 然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数的地址换到新数组，ArrayList就这样完成了一次改头换面。 \r\n\r\n![1586831640327](../assets/1586831640327.png)\r\n\r\n如果你传入了初始容量就用你传入的参数，如果没有，就使用默认的大小。\r\n\r\n### 4、ArrayList怎么进行新增操作的\r\n\r\n有两种方式进行新增操作。\r\n\r\n第一种直接添加元素。\r\n\r\n```java\r\n public boolean add(E e) {\r\n         ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n        elementData[size++] = e;\r\n        return true;\r\n    }\r\n```\r\n\r\n在新增之前有一步检验长度的判断`ensureCapacityInternal`，就是说如果长度不够，是需要扩容的，关于怎么扩容上面已将讲过。\r\n\r\n第二种指定index新增。\r\n\r\n```java\r\npublic void add(int index, E element) {\r\n        rangeCheckForAdd(index);\r\n\r\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n        System.arraycopy(elementData, index, elementData, index + 1,\r\n                         size - index);\r\n        elementData[index] = element;\r\n        size++;\r\n    }\r\n```\r\n\r\n在进行校验之后，及逆行了数组的copy，找一下arraycopy。\r\n\r\n```java\r\npublic static native void arraycopy(Object src,  int  srcPos,\r\n                                        Object dest, int destPos,\r\n                                        int length);\r\n```\r\n\r\n是一个native方法。\r\n\r\n举个例子来理解一下这个方法：\r\n\r\n 比如有下面这样一个数组我需要在index 5的位置去新增一个元素A 。\r\n\r\n![1586833368062](../assets/1586833368062.png)\r\n\r\n 那从代码里面我们可以看到，他复制了一个数组，是从index 5的位置开始的，然后把它放在了index 5+1的位置 。\r\n\r\n![1586833394180](../assets/1586833394180.png)\r\n\r\n 给我们要新增的元素腾出了位置，然后在index的位置放入元素A就完成了新增的操作了 。\r\n\r\n![1586833416714](../assets/1586833416714.png)\r\n\r\n### 5、 ArrayList（int initialCapacity）会不会初始化数组大小？ \r\n\r\n**不会初始化数组大小。**\r\n\r\n通过代码看一下：\r\n\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        ArrayList<Integer> arrayList = new ArrayList(10);\r\n        System.out.println(arrayList.size());\r\n        arrayList.set(5,1);\r\n    }\r\n}\r\n```\r\n\r\n输出结果：报错了。\r\n\r\n![1586841675082](../assets/1586841675082.png)\r\n\r\n\r\n\r\n### 6、ArrayList怎么进行删除操作的？\r\n\r\n看源码：\r\n\r\n```java\r\npublic E remove(int index) {\r\n        rangeCheck(index);\r\n\r\n        modCount++;\r\n        E oldValue = elementData(index);\r\n\r\n        int numMoved = size - index - 1;\r\n        if (numMoved > 0)\r\n            System.arraycopy(elementData, index+1, elementData, index,\r\n                             numMoved);\r\n        elementData[--size] = null; // clear to let GC do its work\r\n\r\n        return oldValue;\r\n    }\r\n```\r\n\r\n从源码中我们可以看到还是arraycopy。\r\n\r\n还是举个例子来理解：\r\n\r\n我们现在要删除index 为5的这个位置。\r\n\r\n![1586842132678](../assets/1586842132678.png)\r\n\r\n 那代码他就复制一个index5+1开始到最后的数组，然后把它放到index开始的位置 \r\n\r\n![1586842157357](../assets/1586842157357.png) index5的位置就成功被”删除“了其实就是被覆盖了，给了你被删除的感觉。 \r\n\r\n 同理他的效率也低，因为数组如果很大的话，一样需要复制和移动的位置就大了。 ','http://qak6euco1.bkt.clouddn.com/tu3.jpg?e=1590125274&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:kdFRIWlg4j8sEhnxNGA4d5beoL4=&attname=','原创',18,1,1,1,1,1,'2020-05-22 12:35:31','2020-05-22 12:35:31',12,1,'ArrayList是数组列表，主要用来装载数据， 当我们装载的是基本类型的数据int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组 Object[] elementData','6',0),(16,'HashMap','# HashMap\r\n\r\n## 源码分析\r\n\r\n基于JDK1.8\r\n\r\n### 构造函数\r\n\r\n4个构造函数\r\n\r\n**HashMap()**\r\n\r\n```java\r\n//1. 无参构造\r\n/**\r\n * Constructs an empty <tt>HashMap</tt> with the default initial capacity\r\n * (16) and the default load factor (0.75).\r\n */\r\n//构造一个空的HashMap,初始容量为16，负载因子是0.75\r\npublic HashMap() {\r\n    this.loadFactor = DEFAULT_LOAD_FACTOR; \r\n}\r\n\r\n//负载因子默认为0.75\r\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\r\n```\r\n\r\n 负载因子，代表了table的填充度有多少，默认是0.75 加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。 所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。 \r\n\r\n\r\n\r\n**HashMap(int initialCapacity)**\r\n\r\n```java\r\n//创建一个初始容量为initialCapacity，负载因子为0.75的HashMap\r\npublic HashMap(int initialCapacity) {\r\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\r\n}\r\n```\r\n\r\n\r\n\r\n**HashMap(int initialCapacity, float loadFactor)**\r\n\r\n```java\r\n//构造一个空的初始容量为initialCapacity，负载因子为loadFactor的HashMap\r\npublic HashMap(int initialCapacity, float loadFactor) {\r\n    if (initialCapacity < 0)\r\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\r\n                                           initialCapacity);\r\n    if (initialCapacity > MAXIMUM_CAPACITY)\r\n        initialCapacity = MAXIMUM_CAPACITY;\r\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\r\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\r\n                                           loadFactor);\r\n    this.loadFactor = loadFactor;\r\n    this.threshold = tableSizeFor(initialCapacity);\r\n}\r\n\r\n//最大容量（1 << 30 也就是2的30次方）\r\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\r\n```\r\n\r\n这里为什么是2的30次方，请看[这篇博客](https://blog.csdn.net/hello_cmy/article/details/105114725)！\r\n\r\n\r\n\r\n设定**threshold**。这个threshold=capacity * loadFactor。当HaspMap的size到了threshold，就会进行resize,也就是扩容。\r\n\r\n\r\n\r\ntableSizeFor()的主要功能是返回一个比给定整数大且最接近2的幂次方整数，如给定10，返回2的4次方16。\r\n\r\n找到tableSizeFor(int cap)的源码：\r\n\r\n```java\r\n/**\r\n * Returns a power of two size for the given target capacity.\r\n */\r\nstatic final int tableSizeFor(int cap) {\r\n    int n = cap - 1;\r\n    n |= n >>> 1; //先进行无符号右移，再做或运算。\r\n    n |= n >>> 2;\r\n    n |= n >>> 4;\r\n    n |= n >>> 8;\r\n    n |= n >>> 16;\r\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\r\n}\r\n```\r\n\r\n\r\n\r\n根据上面给的那个如cap为10。看一下运算过程！\r\n\r\n\r\n\r\n ![img](https://upload-images.jianshu.io/upload_images/5679451-42e4ccca9e5b0392.png?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp) \r\n\r\n\r\n\r\n**HashMap(Map<? extends K, ? extends V> m)**\r\n\r\n```java\r\n//构造一个和制定Map有相同mappings的HashMap，初始容量能充足的容下指定的Map,负载因子为0.75\r\npublic HashMap(Map<? extends K, ? extends V> m) {\r\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\r\n    putMapEntries(m, false);\r\n}\r\n```\r\n\r\n\r\n\r\n直接看putMapEntries(m, false)。源码如下：\r\n\r\n```jva\r\n//将m的所有元素存入本HashMap实例中\r\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\r\n	//得到m中的元素个数\r\n    int s = m.size();\r\n    //当m中有元素时，则需要将map中元素放入本HashMap实例\r\n    if (s > 0) {\r\n    	//判断table是否已初始化，如果未初始化，则先初始化一些变量。（table初始化是在put时）\r\n        if (table == null) { // pre-size\r\n        	//根据待插入的map的size计算要创建的 HashMap 的容量\r\n            float ft = ((float)s / loadFactor) + 1.0F;\r\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\r\n                     (int)ft : MAXIMUM_CAPACITY);\r\n            //把要创建的HashMap 的容量存在 threshold中\r\n            if (t > threshold)\r\n                threshold = tableSizeFor(t);\r\n        }\r\n        //进行扩容\r\n        else if (s > threshold)\r\n            resize();\r\n        //然后就开始遍历 插入的map，将每一个<key, value>插入到本HashMap实例中\r\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\r\n            K key = e.getKey();\r\n            V value = e.getValue();\r\n            //put(K,V)也是调用putVal 方法进行元素的插入\r\n            putVal(hash(key), key, value, false, evict);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\nputMapEntries方法中，如果table为null，那么这时就设置合适的threshold，如果不为空并且指定的map的size > threshold，那么就resize()，然后把指定的map中的所有key,value，通过putVal添加到我们创建的新的map中。\r\n\r\n那咱们先看一下**hash(key)。**\r\n\r\n```java\r\n/**\r\n* key 的hash值的计算是通过hashcode()的高16位异或或低16为异或实现的：\r\n* (h = key.hashCode()) ^ (h >>> 16)\r\n*/\r\n\r\nstatic final int hash(Object key) {\r\n    int h;\r\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\r\n}\r\n```\r\n\r\n```java\r\npublic native int hashCode();\r\n```\r\n\r\n\r\n\r\n异或运算：(h = key.hashCode()) ^ (h >>> 16)\r\n\r\n原来的hashcode:     1111   1111  1111  1111   0100   1100   0000   1010\r\n\r\n移位后的hashcode:  0000   0000   0000  0000   1111  1111   1111   1111\r\n\r\n进行异或运算 结果： 1111  11111   1111  1111   1011   0011  1111  0101\r\n\r\n\r\n\r\n这样做的好处是：可以将hashcode高位和低位的值进行混合做异或运算，而且混合后，低位的信息中加入了高位的信息，这样高位的信息被变相的保留了下来。参杂的元素多了，那么生成的hash值的随机性会增大。\r\n\r\n\r\n\r\n再来看一下**resize() 方法。**\r\n\r\n```java\r\n/**\r\n * Initializes or doubles table size.  If null, allocates in\r\n * accord with initial capacity target held in field threshold.\r\n * Otherwise, because we are using power-of-two expansion, the\r\n * elements from each bin must either stay at same index, or move\r\n * with a power of two offset in the new table.\r\n *\r\n * @return the table\r\n */\r\nfinal Node<K,V>[] resize() {\r\n    //保存当前table\r\n    Node<K,V>[] oldTab = table;\r\n    //保存当前table的容量\r\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\r\n    //保存当前阈值\r\n    int oldThr = threshold;\r\n    //初始化新的table容量和阈值\r\n    int newCap, newThr = 0;\r\n    /*\r\n    1. resize() 方法在size > threshold时被调用。oldCap大于0 代表原来的table非空，\r\n    	oldCap为原表的大小， oldThr（threshold）为 oldCap * load_factor\r\n    */\r\n    if (oldCap > 0) {\r\n        //若旧table容量已超过最大容量，更新阈值为Integer.MAX_VALUE，这样以后不会自动扩容了\r\n        if (oldCap >= MAXIMUM_CAPACITY) {\r\n            threshold = Integer.MAX_VALUE;\r\n            return oldTab;\r\n        }\r\n        //容量翻倍，使用左移，效率更高\r\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\r\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\r\n            newThr = oldThr << 1; // double threshold\r\n    }\r\n    /*\r\n    2. resize() 函数在table为空被调用。oldCap 小于等于0且oldThr 大于0，代表用户\r\n    创建了一个HashMap。但是使用的构造函数为HashMap(int initialCapacity) 或\r\n    HashMap(int initialCapacity, float loadFactor) 或  HashMap(Map<? extends K, ? extends V> m)，导致oldTab为null，oldCap为0，oldThr为用户指定的HashMap的初始容量\r\n    */\r\n    else if (oldThr > 0) // initial capacity was placed in threshold\r\n        //当table没初始化时，threshold持有初始容量。\r\n        newCap = oldThr;\r\n    /*\r\n    3. resize()函数在table为空被调用。oldCap 小于等于0且oldThr 等于0。\r\n    用户调用HashMap()构造函数创建的HashMap，所有值均采用默认值，oldTab(Table)为空，oldCap为0，oldThr为0\r\n    */\r\n    else {               // zero initial threshold signifies using defaults\r\n        newCap = DEFAULT_INITIAL_CAPACITY;\r\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\r\n    }\r\n    //新阈值为0\r\n    if (newThr == 0) {\r\n        float ft = (float)newCap * loadFactor;\r\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\r\n                  (int)ft : Integer.MAX_VALUE);\r\n    }\r\n    threshold = newThr;\r\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\r\n    //初始化table\r\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\r\n    table = newTab;\r\n    if (oldTab != null) {\r\n        //把oldTab中的节点，reHash 到newTab中去\r\n        for (int j = 0; j < oldCap; ++j) {\r\n            Node<K,V> e;\r\n            if ((e = oldTab[j]) != null) {\r\n                oldTab[j] = null;\r\n                //若节点是单节点，直接在newTab中进行重定位\r\n                if (e.next == null)\r\n                    newTab[e.hash & (newCap - 1)] = e;\r\n                //若节点是TreeNode节点，要进行红黑树的rehash操作\r\n                else if (e instanceof TreeNode)\r\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\r\n                //若是链表，进行链表的rehash操作\r\n                else { // preserve order\r\n                    Node<K,V> loHead = null, loTail = null;\r\n                    Node<K,V> hiHead = null, hiTail = null;\r\n                    Node<K,V> next;\r\n                    //将同一桶中的元素根据(e.hash & oldCap)是否为0进行分割\r\n                    do {\r\n                        next = e.next;\r\n                        //根据算法，(e.hash & oldCap) 判断节点位置rehash后是否发生改变\r\n                        //最高位==0，这是索引不变的链表\r\n                        if ((e.hash & oldCap) == 0) {\r\n                            if (loTail == null)\r\n                                loHead = e;\r\n                            else\r\n                                loTail.next = e;\r\n                            loTail = e;\r\n                        }\r\n                        //最高位为1，这是索引发生改变的链表\r\n                        else {\r\n                            if (hiTail == null)\r\n                                hiHead = e;\r\n                            else\r\n                                hiTail.next = e;\r\n                            hiTail = e;\r\n                        }\r\n                    } while ((e = next) != null);\r\n                    if (loTail != null) {\r\n                        loTail.next = null;\r\n                        newTab[j] = loHead;\r\n                    }\r\n                    if (hiTail != null) {\r\n                        hiTail.next = null;\r\n                        //rehash 后节点新的位置一定为原来基础上加上oldCap\r\n                        newTab[j + oldCap] = hiHead;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return newTab;\r\n}\r\n```\r\n\r\n这里使用的是2次幂的扩展，指长度扩为原来的2倍。所以，元素的位置要么是在原来的位置，要么是在原本位置上再移动2次幂的位置。\r\n\r\n如下图，n 为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。\r\n\r\n\r\n\r\n ![img](https://upload-images.jianshu.io/upload_images/5679451-a8f2e1917e6c188a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp) \r\n\r\n\r\n\r\n元素在重新计算hash之后，因为n变为2倍，那么n-的mask范围在高位多1bit（红色）。因此新的index会发生这样的变化:\r\n\r\n ![img](https://upload-images.jianshu.io/upload_images/5679451-b2d09c67373f217a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1064/format/webp) \r\n\r\n\r\n\r\n因此，在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引就变为”原来的索引+ oldCap“  。\r\n\r\n ![img](https://upload-images.jianshu.io/upload_images/5679451-d193fbb84c53dd09.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp) \r\n\r\n\r\n\r\n\r\n\r\n**什么时候扩容：通过上述源码可以看到是在put操作时，即向容器中添加元素时，判断当前容器中的元素的个数是否达到阈值的时候，就要自动扩容了。**\r\n\r\n\r\n\r\n再最后看一下**putVal的源码：**\r\n\r\n```java\r\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\r\n               boolean evict) {\r\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\r\n    //如果table为空或者长度为0，则resize()\r\n    if ((tab = table) == null || (n = tab.length) == 0)\r\n        n = (tab = resize()).length;\r\n    //确定插入table的位置，算法是(n - 1) & hash，在n为2的幂时，相当于取模操作\r\n    if ((p = tab[i = (n - 1) & hash]) == null)\r\n        tab[i] = newNode(hash, key, value, null);\r\n    //在table的i位置发生碰撞，有两种情况：\r\n    //1. key一样，替换value\r\n     //2. key不一样，有两种处理方法：存储在i位置的链表中，存储在红黑树中\r\n    else {\r\n        Node<K,V> e; K k;\r\n        if (p.hash == hash &&\r\n            ((k = p.key) == key || (key != null && key.equals(k))))\r\n            e = p;\r\n        else if (p instanceof TreeNode)\r\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\r\n        else {\r\n            //不是TreeNode，即为链表，遍历链表\r\n            for (int binCount = 0; ; ++binCount) {\r\n                //链表的尾端也没有找到key值相同的节点，则生成一个新的node\r\n                //并且判断链表的节点个数是不是到达转换成红黑树的上界，到达则转换红黑树\r\n                if ((e = p.next) == null) {\r\n                    //创建链表节点并插入 尾部\r\n                    p.next = newNode(hash, key, value, null);\r\n                    //超过了链表的设置长度8就转成红黑树\r\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\r\n                        treeifyBin(tab, hash);\r\n                    break;\r\n                }\r\n                if (e.hash == hash &&\r\n                    ((k = e.key) == key || (key != null && key.equals(k))))\r\n                    break;\r\n                p = e;\r\n            }\r\n        }\r\n        if (e != null) { // existing mapping for key\r\n            V oldValue = e.value;\r\n            if (!onlyIfAbsent || oldValue == null)\r\n                e.value = value;\r\n            afterNodeAccess(e);\r\n            return oldValue;\r\n        }\r\n    }\r\n    ++modCount;\r\n    if (++size > threshold)\r\n        resize();\r\n    afterNodeInsertion(evict);\r\n    return null;\r\n}\r\n```\r\n\r\n\r\n\r\n```java\r\nstatic final int TREEIFY_THRESHOLD = 8;\r\n```\r\n\r\n\r\n\r\n\r\n\r\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181105181728652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvc2hpbWF4aWFvMQ==,size_16,color_FFFFFF,t_70) \r\n\r\n\r\n\r\n\r\n\r\n参考： https://www.jianshu.com/p/ee0de4c99f87 \r\n\r\n最后一张图： https://blog.csdn.net/woshimaxiao1/article/details/83661464 ','http://qak6euco1.bkt.clouddn.com/tu2.jpg?e=1590125274&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:QJXaHKwSXBfb2wnLssTiktZYX5c=&attname=','原创',3,1,1,1,1,1,'2020-05-22 12:38:09','2020-05-23 11:43:35',15,1,'HashMap使用的非常多，在面试与工作中是高频点。','6',0),(17,'Redis主从复制','# Redis主从复制\r\n\r\n## 概念\r\n\r\n> 概念：\r\n\r\n主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点 \r\n\r\n(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。 \r\n\r\nMaster以写为主，Slave 以读为主。 \r\n\r\n==默认情况下，每台Redis服务器都是主节点；== \r\n\r\n且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。\r\n\r\n> 主从复制的作用：\r\n\r\n1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 \r\n\r\n2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务 \r\n\r\n的冗余。 \r\n\r\n3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 \r\n\r\n（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写 \r\n\r\n少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 \r\n\r\n4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复 \r\n\r\n制是Redis高可用的基础。\r\n\r\n\r\n\r\n一般都是使用这种架构：（主节点负责写，从节点负责读）\r\n\r\n![1588561500221](assets/1588561500221.png)\r\n\r\n进行读操作的很多，为了减缓服务器的压力了，一般使用一主二从。\r\n\r\n## 环境配置\r\n\r\n如果对在Linux安装redis不熟悉的话，请看[这篇博客](https://blog.csdn.net/hello_cmy/article/details/105729135)。绝对可以帮助到你。\r\n\r\n> 基本命令：\r\n\r\n```bash\r\ninfo replication  #查看当前库的信息\r\n```\r\n\r\n要清楚：==默认情况下，每台Redis服务器都是主节点；== \r\n\r\n```bash\r\n[root@iZ8vb409m8717t5boglt61Z ~]# cd /usr/local/bin\r\n[root@iZ8vb409m8717t5boglt61Z bin]# redis-cli -p 6379\r\n127.0.0.1:6379> info replication\r\n# Replication\r\nrole:master  #角色 master是主机的意思\r\nconnected_slaves:0  #没有从机\r\nmaster_replid:483d237217de55b0d347256f0d4ea9ed84e88523\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:0\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:0\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:0\r\nrepl_backlog_histlen:0\r\n```\r\n\r\n> 开始配置环境：\r\n\r\n复制三个redis.conf配置文件，分别为redis79.conf，redis80.conf，redis81.conf \r\n\r\n```java\r\n[root@iZ8vb409m8717t5boglt61Z bin]# ls\r\nredis-benchmark  redis-check-rdb  redis-sentinel  yueconfig\r\nredis-check-aof  redis-cli        redis-server\r\n[root@iZ8vb409m8717t5boglt61Z bin]# cd yueconfig\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# ls\r\nredis.conf\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# cp redis.conf redis79.conf\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# cp redis.conf redis80.conf\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# cp redis.conf redis81.conf\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# ls\r\nredis79.conf  redis80.conf  redis81.conf  redis.conf\r\n```\r\n\r\n分别修改三个配置文件：\r\n\r\n```bash\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# vim redis79.conf\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# vim redis80.conf\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# vim redis81.conf\r\n```\r\n\r\n修改的内容为：\r\n\r\n1. 端口\r\n2. daemonize 为 yes\r\n3. pid 名字\r\n4. log 名字\r\n5. dump.rdb 名字\r\n\r\n这里都要修改为对应的，不然会影响后面的操作。\r\n\r\n\r\n\r\n修改完了之后，启动我们的3的redis服务器，可以通过进程信息来查看。\r\n\r\n```bash\r\nps -ef|grep redis #查看进程信息\r\n```\r\n\r\n\r\n\r\n```bash\r\n[root@iZ8vb409m8717t5boglt61Z ~]# cd /usr/local/bin\r\n[root@iZ8vb409m8717t5boglt61Z bin]# ps -ef|grep redis\r\nroot     25342     1  0 09:35 ?        00:00:03 redis-server 127.0.0.1:6379\r\nroot     25526     1  0 10:14 ?        00:00:00 redis-server 127.0.0.1:6380\r\nroot     25532     1  0 10:15 ?        00:00:00 redis-server 127.0.0.1:6381\r\nroot     25556 25538  0 10:16 pts/3    00:00:00 grep --color=auto redis\r\n```\r\n\r\n\r\n\r\n## 一主二从\r\n\r\n==默认情况下，每台Redis服务器都是主节点；== 我们一般情况下只用配置从机就好了！\r\n\r\n我上边配置了79，80，81，这里我让79作为主机，80，81是79的从机（小弟）。\r\n\r\n配置80和81从机。这里只列出来80从机的配置，81类似，就不再列举出了。\r\n\r\n```bash\r\n# 开启服务端\r\nredis-server yueconfig/redis80.conf \r\n\r\n# 开启客户端\r\nredis-cli -p 6380\r\n\r\n# slaveof 主机 端口  \r\n# 找谁当自己的老大\r\nslaveof 127.0.0.1 6379\r\n\r\n#查看当前库的信息\r\ninfo replication\r\n```\r\n\r\n\r\n\r\n```bash\r\n[root@iZ8vb409m8717t5boglt61Z bin]# redis-server yueconfig/redis80.conf \r\n[root@iZ8vb409m8717t5boglt61Z bin]# redis-cli -p 6380\r\n127.0.0.1:6380> slaveof 127.0.0.1 6379\r\nOK\r\n127.0.0.1:6380> info replication\r\n# Replication\r\nrole:slave  #当前角色是从机\r\nmaster_host:127.0.0.1\r\nmaster_port:6379\r\nmaster_link_status:up\r\nmaster_last_io_seconds_ago:7\r\nmaster_sync_in_progress:0\r\nslave_repl_offset:28\r\nslave_priority:100\r\nslave_read_only:1\r\nconnected_slaves:0\r\nmaster_replid:3cfc9f3aa664a35ec4130b6baf1529bb7523b822\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:28\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:28\r\n```\r\n\r\n\r\n\r\n在主机中查看信息。\r\n\r\n```bash\r\n127.0.0.1:6379> info replication\r\n# Replication\r\nrole:master\r\nconnected_slaves:2 #多了两个从机\r\nslave0:ip=127.0.0.1,port=6380,state=online,offset=210,lag=0\r\nslave1:ip=127.0.0.1,port=6381,state=online,offset=210,lag=1\r\nmaster_replid:3cfc9f3aa664a35ec4130b6baf1529bb7523b822\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:210\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:210\r\n\r\n```\r\n\r\n注意：真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，只是暂时的。\r\n\r\n\r\n\r\n> 小细节：主机可以写，从机只可以读。\r\n\r\n主机中的所有信息和数据，都会自动被从机保存。\r\n\r\n测试一下：\r\n\r\n主机写：\r\n\r\n```bash\r\n127.0.0.1:6379> keys *\r\n(empty list or set)\r\n127.0.0.1:6379> set k1 v1\r\nOK\r\n\r\n```\r\n\r\n从机只能读取，不能写。\r\n\r\n```bash\r\n127.0.0.1:6380> keys *\r\n1) \"k1\"\r\n127.0.0.1:6380> get k1\r\n\"v1\"\r\n127.0.0.1:6380> set k2 v2\r\n(error) READONLY You can\'t write against a read only replica.\r\n\r\n```\r\n\r\n\r\n\r\n主机断开连接，从机依旧可以连接到主机的，但是没有写操作，这个时候，如果主机回来了，从机可以直接获取到主机写的信息。\r\n\r\n如果是使用命令行来配置的主从，这个时候如果重启了，就会变会主机！只要变为从机，立马就会从主机中获取值！\r\n\r\n\r\n\r\n如果主机挂了，那么谁来当老大呢？\r\n\r\n可以手动配置，那有人要说了，有没有不用手动配置的，自动选举老大？\r\n\r\n有，那就是哨兵模式！\r\n\r\n## 哨兵模式\r\n\r\n> 概述：\r\n\r\n主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题 。\r\n\r\n\r\n\r\n哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理就是**哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。**\r\n\r\n![1588565924801](assets/1588565924801.png)\r\n\r\n这里的哨兵有两个作用：\r\n\r\n- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。\r\n- 当哨兵检测到master宕机，会自动将slave切换成master，然后通过**发布订阅模式** 通知其他的从服务器，修改配置文件，让它们切换主机。\r\n\r\n然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\r\n\r\n![1588565877735](assets/1588565877735.png)\r\n\r\n假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover（故障转移）过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。\r\n\r\n> 测试：\r\n\r\n我们现在目前的状态是一主（6379）二从（6380、6381）。\r\n\r\n1、我们到刚刚复制的redis.conf目录下（yueconfig）新建一个sentinel.conf文件。\r\n\r\n配置如下 信息：\r\n\r\n注意拼写。\r\n\r\n```bash\r\n# sentinel monitor 被监控的名称 host port 1\r\nsentinel monitor 127.0.0.1 6379 1\r\n\r\n```\r\n\r\n1  代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机。\r\n\r\n\r\n\r\n```bash\r\n[root@iZ8vb409m8717t5boglt61Z bin]# cd yueconfig\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# ls\r\nredis79.conf  redis80.conf  redis81.conf  redis.conf\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# vim sentinel.conf\r\n[root@iZ8vb409m8717t5boglt61Z yueconfig]# cd ..\r\n[root@iZ8vb409m8717t5boglt61Z bin]# ls\r\n6379.log  dump6380.rdb  redis-benchmark  redis-cli       yueconfig\r\n6380.log  dump6381.rdb  redis-check-aof  redis-sentinel\r\n6381.log  dump.rdb      redis-check-rdb  redis-server\r\n\r\n```\r\n\r\n2、启动哨兵\r\n\r\n```bash\r\nredis-sentinel yueconfig/sentinel.conf\r\n\r\n```\r\n\r\n\r\n\r\n```bash\r\n[root@iZ8vb409m8717t5boglt61Z bin]# redis-sentinel yueconfig/sentinel.conf\r\n25584:X 04 May 2020 10:32:13.789 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\r\n25584:X 04 May 2020 10:32:13.789 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=25584, just started\r\n25584:X 04 May 2020 10:32:13.789 # Configuration loaded\r\n                _._                                                  \r\n           _.-``__ \'\'-._                                             \r\n      _.-``    `.  `_.  \'\'-._           Redis 5.0.8 (00000000/0) 64 bit\r\n  .-`` .-```.  ```\\/    _.,_ \'\'-._                                   \r\n (    \'      ,       .-`  | `,    )     Running in sentinel mode\r\n |`-._`-...-` __...-.``-._|\'` _.-\'|     Port: 26379\r\n |    `-._   `._    /     _.-\'    |     PID: 25584\r\n  `-._    `-._  `-./  _.-\'    _.-\'                                   \r\n |`-._`-._    `-.__.-\'    _.-\'_.-\'|                                  \r\n |    `-._`-._        _.-\'_.-\'    |           http://redis.io        \r\n  `-._    `-._`-.__.-\'_.-\'    _.-\'                                   \r\n |`-._`-._    `-.__.-\'    _.-\'_.-\'|                                  \r\n |    `-._`-._        _.-\'_.-\'    |                                  \r\n  `-._    `-._`-.__.-\'_.-\'    _.-\'                                   \r\n      `-._    `-.__.-\'    _.-\'                                       \r\n          `-._        _.-\'                                           \r\n              `-.__.-\'                                               \r\n\r\n25584:X 04 May 2020 10:32:13.790 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\r\n25584:X 04 May 2020 10:32:13.792 # Sentinel ID is cc8ffaf50e789f4a6455ab3a174bbd3b5dc56d3b\r\n25584:X 04 May 2020 10:32:13.792 # +monitor master myredis 127.0.0.1 6379 quorum 1\r\n25584:X 04 May 2020 10:32:13.793 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\r\n25584:X 04 May 2020 10:32:13.794 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\r\n\r\n```\r\n\r\n\r\n\r\n如果主机Master断开了，这时候就会从从机中随机选择一个服务器！（这里有一个投票算法）\r\n\r\n```bash\r\n127.0.0.1:6379> shutdown\r\nnot connected> exit\r\n\r\n```\r\n\r\n\r\n\r\n查看6381的库信息\r\n\r\n```bash\r\n127.0.0.1:6381> info replication\r\n# Replication\r\nrole:master #成为新的主机\r\nconnected_slaves:1\r\nslave0:ip=127.0.0.1,port=6380,state=online,offset=14507,lag=1\r\nmaster_replid:2537105230ad1e01571df9b7b36c206a8f804750\r\nmaster_replid2:3cfc9f3aa664a35ec4130b6baf1529bb7523b822\r\nmaster_repl_offset:14507\r\nsecond_repl_offset:6807\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:127\r\nrepl_backlog_histlen:14381\r\n\r\n```\r\n\r\n\r\n\r\n查看6380库信息\r\n\r\n```bash\r\n127.0.0.1:6380> info replication\r\n# Replication\r\nrole:slave #从机\r\nmaster_host:127.0.0.1\r\nmaster_port:6381  #主机变成了6381\r\nmaster_link_status:up\r\nmaster_last_io_seconds_ago:1\r\nmaster_sync_in_progress:0\r\nslave_repl_offset:13291\r\nslave_priority:100\r\nslave_read_only:1\r\nconnected_slaves:0\r\nmaster_replid:2537105230ad1e01571df9b7b36c206a8f804750\r\nmaster_replid2:3cfc9f3aa664a35ec4130b6baf1529bb7523b822\r\nmaster_repl_offset:13291\r\nsecond_repl_offset:6807\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:13291\r\n\r\n```\r\n\r\n\r\n\r\n哨兵日志：\r\n\r\n![1588567774543](assets/1588567774543.png)\r\n\r\n\r\n\r\n如果主机此时回来了，只能归并到新的主机下，老老实实当小弟，做从机，这就是哨兵模式的规则。\r\n\r\n> 哨兵模式的优缺点：\r\n\r\n优点：\r\n\r\n1. 哨兵集群，基于主从复制模式，所有的主从配置优点，它全有。\r\n2. 主从可以切换，故障可以转移，系统的可用性就会更好。\r\n3. 哨兵模式就是主从模式的升级，手动到自动。\r\n\r\n缺点：\r\n\r\n1. Redis不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦。\r\n2. 实现哨兵模式的配置其实是麻烦的，里面有很多选择。\r\n\r\n\r\n\r\n\r\n\r\n','http://qak6euco1.bkt.clouddn.com/tu3.jpg?e=1590125274&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:kdFRIWlg4j8sEhnxNGA4d5beoL4=&attname=','原创',63,1,1,1,1,1,'2020-05-22 12:39:58','2020-05-23 10:41:43',13,1,'主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点\r\n\r\n(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。','11',3),(18,'详解Linux安装redis最新版5.0.8','# 详解Linux安装redis最新版5.0.8\r\n\r\n如果是在校大学生，可以到阿里云网站去免费领取一个半年的阿里云服务器，不知道现在还可以免费领取不。\r\n\r\n也可以安装虚拟机，在虚拟机上安装redis。\r\n\r\n在windows上安装redis是很简单的，这里不做讲解。\r\n\r\n[redis官网](https://redis.io/)，最新版本是5.0.8。\r\n\r\n![1587696919837](C:\\Users\\moon\\Documents\\typora\\assets\\1587696919837.png)\r\n\r\n> 准备工作\r\n\r\nxshell远程连接工具，xftp文件上传工具。\r\n\r\n推荐360下载。很方便。\r\n\r\n![1587697026741](C:\\Users\\moon\\Documents\\typora\\assets\\1587697026741.png)\r\n\r\n![1587697041778](C:\\Users\\moon\\Documents\\typora\\assets\\1587697041778.png)\r\n\r\n之前我在网上下载找的，没有这个方便。\r\n\r\n这里我已经下载好了这两个软件。\r\n\r\n> 开始安装\r\n\r\n1、官网下载安装包。`redis-5.0.8.tar.gz`\r\n\r\n2、使用xftp把redis的安装包放到服务器上。\r\n\r\n首先你得连接上你自己的服务器。\r\n\r\n![1587697354121](C:\\Users\\moon\\Documents\\typora\\assets\\1587697354121.png)\r\n\r\n直接拖拽redis的安装包。\r\n\r\n![1587703123059](../assets/1587703123059.png)\r\n\r\n\r\n\r\n3、移动到opt下，一般我们放到opt下面的。然后解压redis的安装包。\r\n\r\n```bash\r\n#移动到opt下\r\nmv redis-5.0.8.tar.gz /opt\r\n#解压\r\ntar -zxvf redis-5.0.8.tar.gz\r\n```\r\n\r\n![1587704000805](../assets/1587704000805.png)\r\n\r\n进入redis-5.0.8里，我们可以看到redis的配置文件。redis.conf。\r\n\r\n![1587704063482](../assets/1587704063482.png)\r\n\r\n==注意：不要在windows下解压之后再拖拽到xftp上，在你进行环境安装的时候会发现很多错误，丢失包什么的。这是个坑，亲自试过.==\r\n\r\n4、基本的环境安装\r\n\r\n```bash\r\nyum install gcc-c++\r\n\r\nmake\r\n\r\nmake install\r\n```\r\n\r\n![1587704752721](../assets/1587704752721.png)\r\n\r\n\r\n\r\n![1587704903397](../assets/1587704903397.png)\r\n\r\n\r\n\r\n![1587704847380](../assets/1587704847380.png)\r\n\r\n上述代表你已经安装成功！\r\n\r\n5、redis的默认安装路径：`/usr/local/bin`\r\n\r\n![1587705095299](../assets/1587705095299.png)\r\n\r\n6、将redis的配置文件，复制到我们目录下\r\n\r\n```bash\r\n#创建一个新的文件夹yueconfig\r\nmkdir yueconfig\r\n#复制\r\ncp /opt/redis-5.0.8/redis.conf yueconfig\r\n#进入yueconfig查看\r\n# cd yueconfig\r\n# ls\r\nredis.conf\r\n```\r\n\r\n\r\n\r\n![1587705248163](../assets/1587705248163.png)\r\n\r\n7、redis默认不是后台启动的，修改配置文件！\r\n\r\n```bash\r\nvim redis.conf\r\n```\r\n\r\n![1587705533128](../assets/1587705533128.png)\r\n\r\n\r\n\r\n![1587705441141](../assets/1587705441141.png)\r\n\r\n8、启动redis服务。\r\n\r\n通过指定的配置文件启动。\r\n\r\n```bash\r\nredis-server yueconfig/redis.conf\r\n```\r\n\r\n![1587706204764](../assets/1587706204764.png)\r\n\r\n9、使用客户端 redis-cli 进行连接测试！\r\n\r\n```bash\r\nredis-cli -p 6379\r\n```\r\n\r\n![1587706301045](../assets/1587706301045.png)\r\n\r\n10、查看redis的进程是否开启！\r\n\r\n```bash\r\n# ps -ef|grep redis\r\n```\r\n\r\n![1587706474891](../assets/1587706474891.png)\r\n\r\n11、关闭redis的服务。\r\n\r\n```bash\r\nshutdown\r\nexit\r\n```\r\n\r\n![1587706582243](../assets/1587706582243.png)\r\n\r\n12、再次查看redis的进程是否存在。\r\n\r\n![1587706660315](../assets/1587706660315.png)\r\n\r\n','http://qak6euco1.bkt.clouddn.com/tu4.jpg?e=1590117079&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:5ZxFe7QruNskk0is0nhD_awvlLg=&attname=','原创',5,1,1,1,1,1,'2020-05-22 12:41:24','2020-05-22 12:41:24',13,1,'在Linux系统上安装redis-5.0.8','11',0),(19,'如何判断对象是否死亡？（两种方法）','如何判断对象是否死亡？（两种方法）\r\n堆中几乎存放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象需要回收（也就是死亡，不能再被任何途径使用的对象）。\r\n\r\n有两种方法来判断。\r\n\r\n1、引用计数法\r\n\r\n在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。\r\n\r\n我们能看出来引用计数法原理简单，判定高效，但是在Java领域，至少是主流的Java虚拟机里面都没有用此方法来管理内存。\r\n\r\n主要原因可能是：在两个对象出现循环引用的情况下，此时计数器永远不为0，导致无法对它进行回收。\r\n\r\npublic class Test {\r\n\r\n    public Object instance = null;\r\n\r\n    public static void main(String[] args) {\r\n        Test a = new Test();\r\n        Test b = new Test();\r\n        a.instance = b;\r\n        b.instance = a;\r\n        a = null;\r\n        b = null;\r\n        doSomething();\r\n        }\r\n	}\r\n\r\n\r\n在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。\r\n\r\n2、可达性分析算法\r\n\r\n这个算法的基本思想是通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\r\n\r\n如下图，对象object 5，object 6，object 7，虽然互有关联，但是他们到GC Roots是不可达的，因此他们将会被判定为可回收的对象。\r\n[![](https://img-blog.csdnimg.cn/2020050109414178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlbGxvX2NteQ==,size_16,color_FFFFFF,t_70)](http://https://img-blog.csdnimg.cn/2020050109414178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlbGxvX2NteQ==,size_16,color_FFFFFF,t_70)\r\n\r\n版权声明：本文为CSDN博主「hello_cmy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/hello_cmy/article/details/105874385','http://qak6euco1.bkt.clouddn.com/tu3.jpg?e=1590205594&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:WdGfmiqxIj7vXJV2SXGWqyvXR3I=&attname=','转载',25,1,1,1,1,1,'2020-05-23 10:55:37','2020-05-23 10:55:37',14,1,'两种方法判断对象是否死亡：1、引用计数法 2、可达性分析算法','12',NULL),(20,'单例模式','# 单例模式\r\n\r\n## 1、单例模式定义\r\n\r\n保证一个类仅有一个实例，并提供 一个访问他的全局访问点。\r\n\r\n## 2、为什么要使用单例模式\r\n\r\n在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。\r\n\r\n简单来说使用单例模式可以带来下面几个好处:\r\n\r\n- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\r\n- 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。\r\n\r\n## 3、单例模式的实现方式\r\n\r\n**通常单例模式在Java语言中，有两种构建方式：**\r\n\r\n- **饿汉方式**。指全局的单例实例在类装载时构建\r\n- **懒汉方式**。指全局的单例实例在第一次被使用时构建。\r\n\r\n**不管是那种创建方式，它们通常都存在下面几点相似处：**\r\n\r\n- 单例类必须要有一个 private 访问级别的构造函数，只有这样，才能确保单例不会在系统中的其他代码内被实例化;\r\n\r\n> 1、懒汉式，线程不安全\r\n\r\n这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。\r\n这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 \r\n\r\n```java\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n\r\n    private Singleton() {\r\n\r\n    }\r\n\r\n    public static Singleton getInstance(){\r\n        //判断当前单例是否已经存在，若存在则返回，不存在则再建立单例\r\n        if(instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 2、懒汉式，线程安全\r\n\r\n这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。\r\n优点：第一次调用才初始化，避免内存浪费。\r\n缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。\r\ngetInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\r\n\r\n```java\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n\r\n    private Singleton() {\r\n\r\n    }\r\n\r\n    public static synchronized Singleton getInstance() {\r\n        //判断当前单例是否已经存在，若存在则返回，不存在则再建立单例\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 3、饿汉式\r\n\r\n这种方式比较常用，但容易产生垃圾对象。\r\n优点：没有加锁，执行效率会提高。\r\n缺点：类加载时就初始化，浪费内存。\r\n它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 \r\n\r\n ```java\r\npublic class Singleton {\r\n    private static Singleton instance = new Singleton();\r\n\r\n    private Singleton() {\r\n\r\n    }\r\n\r\n    public static  Singleton getInstance() {\r\n        return instance;\r\n    }\r\n}\r\n ```\r\n\r\n> 4、双检锁/双重校验锁（DCL，即 double-checked locking）\r\n\r\n这种方式采用双锁机制，安全且在多线程情况下能保持高性能。\r\ngetInstance() 的性能对应用程序很关键。 \r\n\r\n```java\r\npublic class Singleton {\r\n    //volatile保证，当dcl变量被初始化成DCL实例时，\r\n    // 多个线程可以正确处理dcl变量\r\n    private volatile static Singleton singleton;\r\n\r\n    private Singleton() {\r\n\r\n    }\r\n\r\n    public static Singleton getInstance(){\r\n        //检查实例，如果不存在，就进入同步代码块\r\n        if(singleton == null) {\r\n            //只要第一次才彻底执行这里的代码\r\n            synchronized (Singleton.class) {\r\n                //进入同步代码块后，再检查一次，如果仍是null，才创建实例\r\n                if(singleton == null) {\r\n                    singleton = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return singleton;\r\n    }\r\n}\r\n```\r\n\r\n> 5、静态内部类\r\n\r\n```java\r\npublic class Singleton {\r\n    \r\n    private static class SingletonHolder {\r\n        private static final Singleton INSTANCE = new Singleton();\r\n    }\r\n    \r\n    private Singleton (){\r\n        \r\n    }\r\n    \r\n    public static final Singleton getInstance() {\r\n        return SingletonHolder.INSTANCE;\r\n    }\r\n}\r\n```\r\n\r\n> 6、枚举\r\n\r\n```java\r\npublic enum Singleton {\r\n    INSTANCE;\r\n    \r\n    public void whateverMethod() {\r\n        \r\n    }\r\n}\r\n```\r\n\r\n','http://qak6euco1.bkt.clouddn.com/tu3.jpg?e=1590205594&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:WdGfmiqxIj7vXJV2SXGWqyvXR3I=&attname=','原创',63,1,1,1,1,1,'2020-05-23 10:57:14','2020-05-23 10:57:14',12,1,'单利模式的多种实现方式。','6',0);

/*Table structure for table `t_blog_tags` */

DROP TABLE IF EXISTS `t_blog_tags`;

CREATE TABLE `t_blog_tags` (
  `id` int NOT NULL AUTO_INCREMENT,
  `tag_id` bigint DEFAULT NULL,
  `blog_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=91 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

/*Data for the table `t_blog_tags` */

insert  into `t_blog_tags`(`id`,`tag_id`,`blog_id`) values (1,3,'4'),(2,4,'1'),(3,4,'3'),(4,5,'3'),(5,5,'4'),(6,7,'2'),(7,6,'5'),(64,5,'3'),(65,4,'3'),(66,4,'6'),(74,7,'10'),(75,8,'11'),(76,8,'12'),(77,8,'13'),(78,4,'1'),(79,8,'12'),(80,6,'1'),(81,6,'1'),(82,6,'13'),(83,5,'3'),(84,4,'3'),(85,3,'4'),(86,6,'5'),(87,4,'6'),(88,11,'17'),(89,6,'16'),(90,6,'16');

/*Table structure for table `t_comment` */

DROP TABLE IF EXISTS `t_comment`;

CREATE TABLE `t_comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `blog_id` bigint DEFAULT NULL,
  `parent_comment_id` bigint DEFAULT NULL,
  `admin_comment` int DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

/*Data for the table `t_comment` */

insert  into `t_comment`(`id`,`nickname`,`email`,`content`,`avatar`,`create_time`,`blog_id`,`parent_comment_id`,`admin_comment`) values (1,'小白','bai@qq.com','小白的评论','/images/avatar1.png','2020-03-15 21:28:13',4,-1,NULL),(2,'小红','hong@qq.com','小红的评论','/images/avatar1.png','2020-03-15 21:35:02',4,-1,NULL),(5,'小蓝','lan@qq.com','小蓝的评论','/images/avatar1.png','2020-03-16 15:04:24',4,-1,NULL),(7,'朱一鸣','691639910@qq.com','博主的评论','/images/avatar1.png','2020-03-16 15:11:07',2,-1,1),(8,'安东尼','2333@qq.com','不论是我的世界车水马龙繁华盛世 还是它们都瞬间消失化为须臾 我都会坚定地走向你 不慌张 不犹豫','/images/avatar1.png','2020-03-24 17:41:17',11,-1,0),(9,'cmy','1127397156@qq.com','nice','/images/avatar1.png','2020-04-17 13:44:29',11,-1,0),(10,'moon','691639910@qq.com','nice','/images/avatar1.png','2020-04-18 16:02:50',1,-1,1),(11,'0201','1125856325@qq.com','1','/images/avatar1.png','2020-05-16 11:48:07',6,-1,0),(12,'0202','7845123698@qq.com','2','/images/avatar1.png','2020-05-16 11:48:32',6,11,0),(13,'小花','7853654523@qq.com','评论。。。','/images/avatar1.png','2020-05-17 16:17:45',12,-1,0),(14,'小米','1236585214@qq.com','回复。。。','/images/avatar1.png','2020-05-17 16:18:12',12,13,0),(15,'小红','4585125745@qq.com','啦','/images/avatar1.png','2020-05-17 16:18:47',12,14,0),(16,'A','4521585412@qq.comqq.com','测试一','/images/avatar1.png','2020-05-19 12:12:43',13,-1,0),(17,'B','457816498@qq.comqq.com','再测试','/images/avatar1.png','2020-05-19 12:13:10',13,16,0),(18,'C','4512635874@qq.comqq.com','再再测试','/images/avatar1.png','2020-05-19 12:13:41',13,17,0),(19,'moon','691639910@qq.com','图片没有处理好。','http://qak6euco1.bkt.clouddn.com/tou.jpg?e=1590118980&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:1hmONvUGTB5rAVjS-HJGPUkhAHM=&attname=','2020-05-22 12:44:18',17,-1,1),(20,'moon','1127397156@qq.com','图片没有处理好。','http://qak6euco1.bkt.clouddn.com/tou.jpg?e=1590118980&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:1hmONvUGTB5rAVjS-HJGPUkhAHM=&attname=','2020-05-22 12:44:23',17,-1,1),(21,'moon','1127397156@qq.com','图片没有处理好。','http://qak6euco1.bkt.clouddn.com/tou.jpg?e=1590118980&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:1hmONvUGTB5rAVjS-HJGPUkhAHM=&attname=','2020-05-22 12:44:39',17,-1,1);

/*Table structure for table `t_message` */

DROP TABLE IF EXISTS `t_message`;

CREATE TABLE `t_message` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `parent_message_id` bigint DEFAULT NULL,
  `admin_message` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=104 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_message` */

insert  into `t_message`(`id`,`nickname`,`email`,`content`,`avatar`,`create_time`,`parent_message_id`,`admin_message`) values (100,'小明','1245@163.com','测试留言','/images/avatar1.png','2020-05-21 14:43:03',-1,'\0'),(101,'小花','1454554@163.com','嘻嘻','/images/avatar1.png','2020-05-21 15:06:24',100,'\0'),(102,'小红','565@163.com','哈哈','/images/avatar1.png','2020-05-21 15:06:50',101,'\0'),(103,'小亮','15464644@qq.com','哦呦','/images/avatar1.png','2020-05-21 15:07:59',-1,'\0');

/*Table structure for table `t_tag` */

DROP TABLE IF EXISTS `t_tag`;

CREATE TABLE `t_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

/*Data for the table `t_tag` */

insert  into `t_tag`(`id`,`name`) values (3,'前端'),(4,'后端'),(5,'springboot'),(6,'java'),(7,'javase'),(8,'杂谈'),(9,'Java基础'),(10,'前后端分离'),(11,'redis'),(12,'JVM');

/*Table structure for table `t_type` */

DROP TABLE IF EXISTS `t_type`;

CREATE TABLE `t_type` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

/*Data for the table `t_type` */

insert  into `t_type`(`id`,`name`) values (1,'前端'),(5,'mybatis'),(7,'springboot'),(9,'html'),(10,'数据结构'),(11,'shiro'),(12,'Java基础'),(13,'redis'),(14,'JVM'),(15,'HashMap'),(16,'前后端分离小例子');

/*Table structure for table `t_user` */

DROP TABLE IF EXISTS `t_user`;

CREATE TABLE `t_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `type` int DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

/*Data for the table `t_user` */

insert  into `t_user`(`id`,`nickname`,`username`,`password`,`email`,`avatar`,`type`,`create_time`,`update_time`) values (1,'moon','moon','e10adc3949ba59abbe56e057f20f883e','691639910@qq.com','http://qak6euco1.bkt.clouddn.com/tou.jpg?e=1590118980&token=0Of9lOuZoO3nb-qBR_li8hcym8udLrBxNFmjOhVO:1hmONvUGTB5rAVjS-HJGPUkhAHM=&attname=',1,'2020-03-08 18:25:26',NULL);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
